# 推荐系统实践项目概述
# Recommender Systems Practice Project Overview

**个性化AI的核心 - 让每个用户都获得量身定制的体验**
**The Core of Personalized AI - Giving Every User a Tailored Experience**

---

## 🎯 项目目标 | Project Goals

推荐系统是现代互联网最成功的AI应用之一！从电商购物到视频娱乐，从新闻阅读到音乐欣赏，推荐系统无处不在。通过这个项目，你将掌握：
Recommender systems are one of the most successful AI applications in the modern internet! From e-commerce shopping to video entertainment, from news reading to music appreciation, recommender systems are everywhere. Through this project, you will master:

- **协同过滤算法** | **Collaborative Filtering**: 基于用户行为的推荐核心技术
- **内容推荐系统** | **Content-based Recommendation**: 基于物品特征的推荐方法
- **深度学习推荐** | **Deep Learning Recommendation**: 现代推荐系统的前沿技术
- **实际部署应用** | **Real Deployment**: 构建可扩展的推荐服务系统

## 🔬 为什么推荐系统如此重要？| Why are Recommender Systems So Important?

**推荐系统正在重塑信息消费的方式！**
**Recommender systems are reshaping the way we consume information!**

Netflix的个性化推荐贡献了80%的观看时间，Amazon的推荐算法带来了35%的销售额，TikTok的推荐算法让用户平均使用时长超过90分钟。推荐系统不仅是技术，更是连接用户与内容的智能桥梁，创造了数千亿美元的商业价值。

Netflix's personalized recommendations contribute to 80% of viewing time, Amazon's recommendation algorithm brings 35% of sales, and TikTok's recommendation algorithm makes users spend an average of over 90 minutes. Recommender systems are not just technology, but intelligent bridges connecting users with content, creating hundreds of billions of dollars in business value.

### 推荐系统的发展历程 | Evolution of Recommender Systems
```
1990s: 协同过滤起源 | Origin of Collaborative Filtering
2000s: 矩阵分解技术 | Matrix Factorization Techniques
2010s: 深度学习革命 | Deep Learning Revolution
2015s: 神经协同过滤 | Neural Collaborative Filtering
2020s: 大模型推荐 | Large Model Recommendations
```

## 📚 项目结构深度解析 | Deep Project Structure Analysis

### 01_协同过滤系统 | Collaborative Filtering Systems

**挖掘用户行为中的隐藏模式！**
**Mine hidden patterns in user behavior!**

#### 用户协同过滤 | User-based Collaborative Filtering

**项目核心 | Project Core:**
用户协同过滤基于"相似用户喜欢相似物品"的假设，通过寻找相似用户来进行推荐。

User-based collaborative filtering is based on the assumption that "similar users like similar items", making recommendations by finding similar users.

**核心算法原理 | Core Algorithm Principles:**

**用户相似度计算 | User Similarity Calculation:**
```python
# 余弦相似度 | Cosine Similarity
def cosine_similarity(user_a, user_b):
    """
    计算两个用户的余弦相似度
    Calculate cosine similarity between two users
    """
    dot_product = np.dot(user_a, user_b)
    norm_a = np.linalg.norm(user_a)
    norm_b = np.linalg.norm(user_b)
    
    if norm_a == 0 or norm_b == 0:
        return 0
    
    return dot_product / (norm_a * norm_b)

# 皮尔逊相关系数 | Pearson Correlation Coefficient
def pearson_correlation(user_a, user_b):
    """
    计算两个用户的皮尔逊相关系数
    Calculate Pearson correlation coefficient between two users
    """
    # 找到两个用户都评分的物品
    # Find items rated by both users
    common_items = set(user_a.keys()) & set(user_b.keys())
    
    if len(common_items) == 0:
        return 0
    
    # 计算平均分 | Calculate mean ratings
    mean_a = np.mean([user_a[item] for item in common_items])
    mean_b = np.mean([user_b[item] for item in common_items])
    
    # 计算协方差和方差 | Calculate covariance and variance
    numerator = sum((user_a[item] - mean_a) * (user_b[item] - mean_b) 
                   for item in common_items)
    
    var_a = sum((user_a[item] - mean_a) ** 2 for item in common_items)
    var_b = sum((user_b[item] - mean_b) ** 2 for item in common_items)
    
    denominator = np.sqrt(var_a * var_b)
    
    if denominator == 0:
        return 0
    
    return numerator / denominator
```

**完整实现 | Complete Implementation:**
```python
import numpy as np
import pandas as pd
from scipy.sparse import csr_matrix
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.model_selection import train_test_split
import matplotlib.pyplot as plt
import seaborn as sns

class UserBasedCollaborativeFiltering:
    """
    基于用户的协同过滤推荐系统
    User-based Collaborative Filtering Recommender System
    """
    def __init__(self, n_neighbors=20, similarity_metric='cosine'):
        self.n_neighbors = n_neighbors
        self.similarity_metric = similarity_metric
        self.user_item_matrix = None
        self.user_similarity_matrix = None
        self.user_mean_ratings = None
        
    def fit(self, ratings_df):
        """
        训练推荐模型
        Train the recommendation model
        
        Args:
            ratings_df: DataFrame with columns ['user_id', 'item_id', 'rating']
        """
        print("构建用户-物品评分矩阵...")
        print("Building user-item rating matrix...")
        
        # 构建用户-物品评分矩阵 | Build user-item rating matrix
        self.user_item_matrix = ratings_df.pivot_table(
            index='user_id', 
            columns='item_id', 
            values='rating',
            fill_value=0
        )
        
        # 计算用户平均评分 | Calculate user mean ratings
        self.user_mean_ratings = self.user_item_matrix.mean(axis=1)
        
        print("计算用户相似度矩阵...")
        print("Computing user similarity matrix...")
        
        # 计算用户相似度矩阵 | Compute user similarity matrix
        if self.similarity_metric == 'cosine':
            self.user_similarity_matrix = cosine_similarity(self.user_item_matrix)
        elif self.similarity_metric == 'pearson':
            self.user_similarity_matrix = self._compute_pearson_similarity()
        
        # 转换为DataFrame便于处理 | Convert to DataFrame for easier handling
        self.user_similarity_matrix = pd.DataFrame(
            self.user_similarity_matrix,
            index=self.user_item_matrix.index,
            columns=self.user_item_matrix.index
        )
        
        print("模型训练完成！")
        print("Model training completed!")
        
        return self
    
    def _compute_pearson_similarity(self):
        """
        计算皮尔逊相关系数相似度矩阵
        Compute Pearson correlation similarity matrix
        """
        # 中心化评分矩阵 | Center the rating matrix
        centered_matrix = self.user_item_matrix.sub(self.user_mean_ratings, axis=0)
        
        # 计算相关系数 | Compute correlation coefficients
        correlation_matrix = np.corrcoef(centered_matrix.fillna(0))
        
        # 处理NaN值 | Handle NaN values
        correlation_matrix = np.nan_to_num(correlation_matrix)
        
        return correlation_matrix
    
    def predict_rating(self, user_id, item_id):
        """
        预测用户对物品的评分
        Predict user's rating for an item
        """
        if user_id not in self.user_item_matrix.index:
            return self.user_mean_ratings.mean()  # 返回全局平均分
        
        if item_id not in self.user_item_matrix.columns:
            return self.user_mean_ratings[user_id]  # 返回用户平均分
        
        # 如果用户已经评分过该物品 | If user has already rated this item
        if self.user_item_matrix.loc[user_id, item_id] != 0:
            return self.user_item_matrix.loc[user_id, item_id]
        
        # 找到相似用户 | Find similar users
        user_similarities = self.user_similarity_matrix.loc[user_id]
        
        # 找到评分过该物品的用户 | Find users who rated this item
        item_raters = self.user_item_matrix[self.user_item_matrix[item_id] != 0].index
        
        # 计算相似用户对该物品的评分 | Calculate similar users' ratings for this item
        similar_users = user_similarities[item_raters]
        
        # 选择最相似的K个用户 | Select top-K similar users
        top_similar_users = similar_users.nlargest(self.n_neighbors)
        
        if len(top_similar_users) == 0:
            return self.user_mean_ratings[user_id]
        
        # 计算加权平均评分 | Calculate weighted average rating
        numerator = 0
        denominator = 0
        
        for similar_user, similarity in top_similar_users.items():
            if similarity > 0:  # 只考虑正相关的用户
                rating = self.user_item_matrix.loc[similar_user, item_id]
                user_mean = self.user_mean_ratings[similar_user]
                
                # 使用中心化评分 | Use centered ratings
                numerator += similarity * (rating - user_mean)
                denominator += abs(similarity)
        
        if denominator == 0:
            return self.user_mean_ratings[user_id]
        
        # 预测评分 = 用户平均分 + 加权平均偏差
        # Predicted rating = user mean + weighted average deviation
        predicted_rating = self.user_mean_ratings[user_id] + (numerator / denominator)
        
        # 限制评分范围 | Constrain rating range
        return max(1, min(5, predicted_rating))
    
    def recommend_items(self, user_id, n_recommendations=10):
        """
        为用户推荐物品
        Recommend items for a user
        """
        if user_id not in self.user_item_matrix.index:
            print(f"用户 {user_id} 不存在于训练数据中")
            print(f"User {user_id} not found in training data")
            return []
        
        # 找到用户未评分的物品 | Find items not rated by the user
        user_ratings = self.user_item_matrix.loc[user_id]
        unrated_items = user_ratings[user_ratings == 0].index
        
        # 预测所有未评分物品的评分 | Predict ratings for all unrated items
        predictions = []
        for item_id in unrated_items:
            predicted_rating = self.predict_rating(user_id, item_id)
            predictions.append((item_id, predicted_rating))
        
        # 按预测评分排序 | Sort by predicted rating
        predictions.sort(key=lambda x: x[1], reverse=True)
        
        # 返回top-N推荐 | Return top-N recommendations
        return predictions[:n_recommendations]
    
    def evaluate(self, test_df):
        """
        评估推荐系统性能
        Evaluate recommender system performance
        """
        print("评估推荐系统性能...")
        print("Evaluating recommender system performance...")
        
        mae_scores = []  # 平均绝对误差 | Mean Absolute Error
        rmse_scores = []  # 均方根误差 | Root Mean Squared Error
        
        for _, row in test_df.iterrows():
            user_id = row['user_id']
            item_id = row['item_id']
            true_rating = row['rating']
            
            predicted_rating = self.predict_rating(user_id, item_id)
            
            mae_scores.append(abs(true_rating - predicted_rating))
            rmse_scores.append((true_rating - predicted_rating) ** 2)
        
        mae = np.mean(mae_scores)
        rmse = np.sqrt(np.mean(rmse_scores))
        
        print(f"平均绝对误差 (MAE): {mae:.4f}")
        print(f"均方根误差 (RMSE): {rmse:.4f}")
        print(f"Mean Absolute Error (MAE): {mae:.4f}")
        print(f"Root Mean Squared Error (RMSE): {rmse:.4f}")
        
        return {'MAE': mae, 'RMSE': rmse}
    
    def analyze_user_similarity(self, user_id, top_k=10):
        """
        分析用户相似度
        Analyze user similarity
        """
        if user_id not in self.user_similarity_matrix.index:
            print(f"用户 {user_id} 不存在")
            return
        
        # 获取最相似的用户 | Get most similar users
        similar_users = self.user_similarity_matrix.loc[user_id].nlargest(top_k + 1)[1:]  # 排除自己
        
        print(f"与用户 {user_id} 最相似的 {top_k} 个用户:")
        print(f"Top {top_k} users most similar to user {user_id}:")
        
        for similar_user, similarity in similar_users.items():
            print(f"用户 {similar_user}: 相似度 {similarity:.4f}")
            print(f"User {similar_user}: Similarity {similarity:.4f}")
        
        return similar_users
    
    def visualize_similarity_distribution(self):
        """
        可视化相似度分布
        Visualize similarity distribution
        """
        # 提取上三角矩阵的相似度值 | Extract similarity values from upper triangle
        similarity_values = []
        n_users = len(self.user_similarity_matrix)
        
        for i in range(n_users):
            for j in range(i + 1, n_users):
                similarity_values.append(self.user_similarity_matrix.iloc[i, j])
        
        # 绘制分布图 | Plot distribution
        plt.figure(figsize=(12, 5))
        
        plt.subplot(1, 2, 1)
        plt.hist(similarity_values, bins=50, alpha=0.7, edgecolor='black')
        plt.title('User Similarity Distribution')
        plt.xlabel('Similarity Score')
        plt.ylabel('Frequency')
        plt.grid(True, alpha=0.3)
        
        plt.subplot(1, 2, 2)
        plt.boxplot(similarity_values)
        plt.title('User Similarity Box Plot')
        plt.ylabel('Similarity Score')
        plt.grid(True, alpha=0.3)
        
        plt.tight_layout()
        plt.show()
        
        # 统计信息 | Statistics
        print(f"相似度统计信息 | Similarity Statistics:")
        print(f"平均值 | Mean: {np.mean(similarity_values):.4f}")
        print(f"标准差 | Std: {np.std(similarity_values):.4f}")
        print(f"最小值 | Min: {np.min(similarity_values):.4f}")
        print(f"最大值 | Max: {np.max(similarity_values):.4f}")
```

#### 物品协同过滤 | Item-based Collaborative Filtering

**项目特色 | Project Features:**
物品协同过滤基于"喜欢相似物品的用户"的假设，通过物品间的相似性进行推荐，具有更好的稳定性。

Item-based collaborative filtering is based on the assumption of "users who like similar items", making recommendations through item similarities with better stability.

**物品相似度计算 | Item Similarity Calculation:**
```python
class ItemBasedCollaborativeFiltering:
    """
    基于物品的协同过滤推荐系统
    Item-based Collaborative Filtering Recommender System
    """
    def __init__(self, n_neighbors=20, similarity_metric='cosine'):
        self.n_neighbors = n_neighbors
        self.similarity_metric = similarity_metric
        self.user_item_matrix = None
        self.item_similarity_matrix = None
        self.item_mean_ratings = None
        
    def fit(self, ratings_df):
        """
        训练推荐模型
        Train the recommendation model
        """
        print("构建用户-物品评分矩阵...")
        print("Building user-item rating matrix...")
        
        # 构建用户-物品评分矩阵 | Build user-item rating matrix
        self.user_item_matrix = ratings_df.pivot_table(
            index='user_id', 
            columns='item_id', 
            values='rating',
            fill_value=0
        )
        
        # 计算物品平均评分 | Calculate item mean ratings
        self.item_mean_ratings = self.user_item_matrix.mean(axis=0)
        
        print("计算物品相似度矩阵...")
        print("Computing item similarity matrix...")
        
        # 计算物品相似度矩阵（转置矩阵）| Compute item similarity matrix (transpose)
        if self.similarity_metric == 'cosine':
            self.item_similarity_matrix = cosine_similarity(self.user_item_matrix.T)
        elif self.similarity_metric == 'pearson':
            self.item_similarity_matrix = self._compute_pearson_similarity()
        
        # 转换为DataFrame | Convert to DataFrame
        self.item_similarity_matrix = pd.DataFrame(
            self.item_similarity_matrix,
            index=self.user_item_matrix.columns,
            columns=self.user_item_matrix.columns
        )
        
        print("模型训练完成！")
        print("Model training completed!")
        
        return self
    
    def _compute_pearson_similarity(self):
        """
        计算物品间的皮尔逊相关系数
        Compute Pearson correlation between items
        """
        # 转置矩阵，使物品成为行 | Transpose matrix to make items as rows
        item_matrix = self.user_item_matrix.T
        
        # 中心化评分矩阵 | Center the rating matrix
        centered_matrix = item_matrix.sub(self.item_mean_ratings, axis=0)
        
        # 计算相关系数 | Compute correlation coefficients
        correlation_matrix = np.corrcoef(centered_matrix.fillna(0))
        
        # 处理NaN值 | Handle NaN values
        correlation_matrix = np.nan_to_num(correlation_matrix)
        
        return correlation_matrix
    
    def predict_rating(self, user_id, item_id):
        """
        预测用户对物品的评分
        Predict user's rating for an item
        """
        if user_id not in self.user_item_matrix.index:
            return self.item_mean_ratings.mean()
        
        if item_id not in self.user_item_matrix.columns:
            return self.user_item_matrix.loc[user_id].mean()
        
        # 如果用户已经评分过该物品 | If user has already rated this item
        if self.user_item_matrix.loc[user_id, item_id] != 0:
            return self.user_item_matrix.loc[user_id, item_id]
        
        # 获取用户评分过的物品 | Get items rated by the user
        user_ratings = self.user_item_matrix.loc[user_id]
        rated_items = user_ratings[user_ratings != 0]
        
        if len(rated_items) == 0:
            return self.item_mean_ratings[item_id]
        
        # 获取目标物品与用户评分物品的相似度 | Get similarities between target item and user-rated items
        item_similarities = self.item_similarity_matrix.loc[item_id, rated_items.index]
        
        # 选择最相似的K个物品 | Select top-K similar items
        top_similar_items = item_similarities.nlargest(self.n_neighbors)
        
        if len(top_similar_items) == 0:
            return self.item_mean_ratings[item_id]
        
        # 计算加权平均评分 | Calculate weighted average rating
        numerator = 0
        denominator = 0
        
        for similar_item, similarity in top_similar_items.items():
            if similarity > 0:  # 只考虑正相关的物品
                rating = user_ratings[similar_item]
                item_mean = self.item_mean_ratings[similar_item]
                
                # 使用中心化评分 | Use centered ratings
                numerator += similarity * (rating - item_mean)
                denominator += abs(similarity)
        
        if denominator == 0:
            return self.item_mean_ratings[item_id]
        
        # 预测评分 = 物品平均分 + 加权平均偏差
        # Predicted rating = item mean + weighted average deviation
        predicted_rating = self.item_mean_ratings[item_id] + (numerator / denominator)
        
        # 限制评分范围 | Constrain rating range
        return max(1, min(5, predicted_rating))
    
    def recommend_items(self, user_id, n_recommendations=10):
        """
        为用户推荐物品
        Recommend items for a user
        """
        if user_id not in self.user_item_matrix.index:
            print(f"用户 {user_id} 不存在于训练数据中")
            return []
        
        # 找到用户未评分的物品 | Find items not rated by the user
        user_ratings = self.user_item_matrix.loc[user_id]
        unrated_items = user_ratings[user_ratings == 0].index
        
        # 预测所有未评分物品的评分 | Predict ratings for all unrated items
        predictions = []
        for item_id in unrated_items:
            predicted_rating = self.predict_rating(user_id, item_id)
            predictions.append((item_id, predicted_rating))
        
        # 按预测评分排序 | Sort by predicted rating
        predictions.sort(key=lambda x: x[1], reverse=True)
        
        return predictions[:n_recommendations]
    
    def find_similar_items(self, item_id, n_similar=10):
        """
        找到与指定物品相似的物品
        Find items similar to a specified item
        """
        if item_id not in self.item_similarity_matrix.index:
            print(f"物品 {item_id} 不存在")
            return []
        
        # 获取最相似的物品 | Get most similar items
        similar_items = self.item_similarity_matrix.loc[item_id].nlargest(n_similar + 1)[1:]  # 排除自己
        
        return list(similar_items.items())
```

### 02_内容推荐系统 | Content-based Recommendation Systems

**基于物品特征的智能推荐！**
**Intelligent recommendations based on item features!**

#### 基于内容的推荐 | Content-based Recommendation

**项目核心 | Project Core:**
内容推荐通过分析物品的特征和用户的偏好历史，为用户推荐具有相似特征的物品。

Content-based recommendation analyzes item features and user preference history to recommend items with similar characteristics.

**TF-IDF特征提取 | TF-IDF Feature Extraction:**
```python
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity, linear_kernel
import pandas as pd
import numpy as np

class ContentBasedRecommender:
    """
    基于内容的推荐系统
    Content-based Recommender System
    """
    def __init__(self, content_features=['genre', 'director', 'actors', 'description']):
        self.content_features = content_features
        self.tfidf_vectorizer = TfidfVectorizer(
            max_features=10000,
            stop_words='english',
            ngram_range=(1, 2),
            min_df=2,
            max_df=0.8
        )
        self.content_matrix = None
        self.item_features_df = None
        self.user_profiles = {}
        
    def fit(self, items_df, ratings_df):
        """
        训练内容推荐模型
        Train content-based recommendation model
        
        Args:
            items_df: DataFrame with item features
            ratings_df: DataFrame with user ratings
        """
        print("构建物品内容特征矩阵...")
        print("Building item content feature matrix...")
        
        self.item_features_df = items_df.copy()
        
        # 合并所有文本特征 | Combine all text features
        combined_features = []
        for _, item in items_df.iterrows():
            features = []
            for feature in self.content_features:
                if feature in item and pd.notna(item[feature]):
                    if isinstance(item[feature], str):
                        features.append(item[feature])
                    else:
                        features.append(str(item[feature]))
            combined_features.append(' '.join(features))
        
        # 使用TF-IDF向量化 | Vectorize using TF-IDF
        self.content_matrix = self.tfidf_vectorizer.fit_transform(combined_features)
        
        print("构建用户偏好档案...")
        print("Building user preference profiles...")
        
        # 构建用户偏好档案 | Build user preference profiles
        self._build_user_profiles(ratings_df)
        
        print("内容推荐模型训练完成！")
        print("Content-based model training completed!")
        
        return self
    
    def _build_user_profiles(self, ratings_df):
        """
        构建用户偏好档案
        Build user preference profiles
        """
        for user_id in ratings_df['user_id'].unique():
            user_ratings = ratings_df[ratings_df['user_id'] == user_id]
            
            # 计算用户对每个物品特征的偏好权重 | Calculate user preference weights for each item feature
            user_profile = np.zeros(self.content_matrix.shape[1])
            total_weight = 0
            
            for _, rating_row in user_ratings.iterrows():
                item_id = rating_row['item_id']
                rating = rating_row['rating']
                
                # 找到物品在特征矩阵中的索引 | Find item index in feature matrix
                item_idx = self.item_features_df[self.item_features_df['item_id'] == item_id].index
                
                if len(item_idx) > 0:
                    item_idx = item_idx[0]
                    item_features = self.content_matrix[item_idx].toarray().flatten()
                    
                    # 使用评分作为权重 | Use rating as weight
                    weight = rating - 3  # 中心化评分 (假设评分范围1-5)
                    user_profile += weight * item_features
                    total_weight += abs(weight)
            
            # 归一化用户档案 | Normalize user profile
            if total_weight > 0:
                user_profile = user_profile / total_weight
            
            self.user_profiles[user_id] = user_profile
    
    def predict_rating(self, user_id, item_id):
        """
        预测用户对物品的评分
        Predict user's rating for an item
        """
        if user_id not in self.user_profiles:
            return 3.0  # 默认中性评分
        
        # 找到物品特征 | Find item features
        item_idx = self.item_features_df[self.item_features_df['item_id'] == item_id].index
        
        if len(item_idx) == 0:
            return 3.0
        
        item_idx = item_idx[0]
        item_features = self.content_matrix[item_idx].toarray().flatten()
        user_profile = self.user_profiles[user_id]
        
        # 计算用户档案与物品特征的相似度 | Calculate similarity between user profile and item features
        similarity = np.dot(user_profile, item_features)
        
        # 转换为1-5的评分范围 | Convert to 1-5 rating scale
        predicted_rating = 3 + 2 * similarity  # 假设相似度在[-1, 1]范围内
        
        return max(1, min(5, predicted_rating))
    
    def recommend_items(self, user_id, n_recommendations=10, exclude_rated=True):
        """
        为用户推荐物品
        Recommend items for a user
        """
        if user_id not in self.user_profiles:
            print(f"用户 {user_id} 没有偏好档案")
            return []
        
        # 计算所有物品的预测评分 | Calculate predicted ratings for all items
        predictions = []
        for idx, item_row in self.item_features_df.iterrows():
            item_id = item_row['item_id']
            predicted_rating = self.predict_rating(user_id, item_id)
            predictions.append((item_id, predicted_rating))
        
        # 按预测评分排序 | Sort by predicted rating
        predictions.sort(key=lambda x: x[1], reverse=True)
        
        return predictions[:n_recommendations]
    
    def find_similar_items(self, item_id, n_similar=10):
        """
        找到内容相似的物品
        Find content-similar items
        """
        # 找到物品索引 | Find item index
        item_idx = self.item_features_df[self.item_features_df['item_id'] == item_id].index
        
        if len(item_idx) == 0:
            print(f"物品 {item_id} 不存在")
            return []
        
        item_idx = item_idx[0]
        
        # 计算与所有物品的余弦相似度 | Calculate cosine similarity with all items
        similarities = cosine_similarity(
            self.content_matrix[item_idx], 
            self.content_matrix
        ).flatten()
        
        # 获取最相似的物品索引 | Get indices of most similar items
        similar_indices = similarities.argsort()[::-1][1:n_similar+1]  # 排除自己
        
        # 返回相似物品和相似度 | Return similar items and similarities
        similar_items = []
        for idx in similar_indices:
            similar_item_id = self.item_features_df.iloc[idx]['item_id']
            similarity_score = similarities[idx]
            similar_items.append((similar_item_id, similarity_score))
        
        return similar_items
    
    def analyze_user_preferences(self, user_id, top_features=10):
        """
        分析用户偏好特征
        Analyze user preference features
        """
        if user_id not in self.user_profiles:
            print(f"用户 {user_id} 没有偏好档案")
            return
        
        user_profile = self.user_profiles[user_id]
        feature_names = self.tfidf_vectorizer.get_feature_names_out()
        
        # 获取权重最高的特征 | Get features with highest weights
        top_feature_indices = user_profile.argsort()[::-1][:top_features]
        
        print(f"用户 {user_id} 的偏好特征:")
        print(f"User {user_id}'s preference features:")
        
        for i, feature_idx in enumerate(top_feature_indices):
            feature_name = feature_names[feature_idx]
            weight = user_profile[feature_idx]
            print(f"{i+1}. {feature_name}: {weight:.4f}")
```

#### 混合推荐系统 | Hybrid Recommendation System

**项目价值 | Project Value:**
混合推荐系统结合多种推荐技术的优势，能够提供更准确和多样化的推荐。

Hybrid recommendation systems combine the advantages of multiple recommendation techniques to provide more accurate and diverse recommendations.

**线性组合混合方法 | Linear Combination Hybrid Method:**
```python
class HybridRecommender:
    """
    混合推荐系统
    Hybrid Recommender System
    """
    def __init__(self, cf_weight=0.4, content_weight=0.4, popularity_weight=0.2):
        self.cf_weight = cf_weight
        self.content_weight = content_weight
        self.popularity_weight = popularity_weight
        
        # 各个推荐组件 | Individual recommendation components
        self.cf_recommender = None
        self.content_recommender = None
        self.popularity_scores = None
        
    def fit(self, ratings_df, items_df):
        """
        训练混合推荐系统
        Train hybrid recommendation system
        """
        print("训练协同过滤组件...")
        print("Training collaborative filtering component...")
        
        # 训练协同过滤推荐器 | Train collaborative filtering recommender
        self.cf_recommender = ItemBasedCollaborativeFiltering()
        self.cf_recommender.fit(ratings_df)
        
        print("训练内容推荐组件...")
        print("Training content-based component...")
        
        # 训练内容推荐器 | Train content-based recommender
        self.content_recommender = ContentBasedRecommender()
        self.content_recommender.fit(items_df, ratings_df)
        
        print("计算物品流行度...")
        print("Computing item popularity...")
        
        # 计算物品流行度分数 | Compute item popularity scores
        item_popularity = ratings_df['item_id'].value_counts()
        max_popularity = item_popularity.max()
        self.popularity_scores = (item_popularity / max_popularity).to_dict()
        
        print("混合推荐系统训练完成！")
        print("Hybrid recommendation system training completed!")
        
        return self
    
    def predict_rating(self, user_id, item_id):
        """
        预测评分（混合多种方法）
        Predict rating (hybrid of multiple methods)
        """
        # 协同过滤预测 | Collaborative filtering prediction
        cf_rating = self.cf_recommender.predict_rating(user_id, item_id)
        
        # 内容推荐预测 | Content-based prediction
        content_rating = self.content_recommender.predict_rating(user_id, item_id)
        
        # 流行度分数 | Popularity score
        popularity_score = self.popularity_scores.get(item_id, 0)
        popularity_rating = 1 + 4 * popularity_score  # 转换为1-5分
        
        # 线性组合 | Linear combination
        hybrid_rating = (
            self.cf_weight * cf_rating +
            self.content_weight * content_rating +
            self.popularity_weight * popularity_rating
        )
        
        return max(1, min(5, hybrid_rating))
    
    def recommend_items(self, user_id, n_recommendations=10):
        """
        混合推荐
        Hybrid recommendation
        """
        # 获取各种推荐方法的结果 | Get results from different recommendation methods
        cf_recommendations = self.cf_recommender.recommend_items(user_id, n_recommendations * 2)
        content_recommendations = self.content_recommender.recommend_items(user_id, n_recommendations * 2)
        
        # 合并推荐结果 | Combine recommendation results
        all_items = set()
        for item_id, _ in cf_recommendations:
            all_items.add(item_id)
        for item_id, _ in content_recommendations:
            all_items.add(item_id)
        
        # 计算混合评分 | Calculate hybrid scores
        hybrid_recommendations = []
        for item_id in all_items:
            hybrid_rating = self.predict_rating(user_id, item_id)
            hybrid_recommendations.append((item_id, hybrid_rating))
        
        # 按混合评分排序 | Sort by hybrid scores
        hybrid_recommendations.sort(key=lambda x: x[1], reverse=True)
        
        return hybrid_recommendations[:n_recommendations]
    
    def evaluate_components(self, test_df):
        """
        评估各个组件的性能
        Evaluate performance of individual components
        """
        print("评估各个推荐组件的性能...")
        print("Evaluating performance of individual recommendation components...")
        
        # 评估协同过滤 | Evaluate collaborative filtering
        cf_mae, cf_rmse = self._evaluate_single_component(test_df, 'cf')
        
        # 评估内容推荐 | Evaluate content-based
        content_mae, content_rmse = self._evaluate_single_component(test_df, 'content')
        
        # 评估混合系统 | Evaluate hybrid system
        hybrid_mae, hybrid_rmse = self._evaluate_single_component(test_df, 'hybrid')
        
        # 打印结果 | Print results
        print(f"\n性能对比 | Performance Comparison:")
        print(f"协同过滤 CF - MAE: {cf_mae:.4f}, RMSE: {cf_rmse:.4f}")
        print(f"内容推荐 Content - MAE: {content_mae:.4f}, RMSE: {content_rmse:.4f}")
        print(f"混合系统 Hybrid - MAE: {hybrid_mae:.4f}, RMSE: {hybrid_rmse:.4f}")
        
        return {
            'CF': {'MAE': cf_mae, 'RMSE': cf_rmse},
            'Content': {'MAE': content_mae, 'RMSE': content_rmse},
            'Hybrid': {'MAE': hybrid_mae, 'RMSE': hybrid_rmse}
        }
    
    def _evaluate_single_component(self, test_df, component_type):
        """
        评估单个组件
        Evaluate single component
        """
        mae_scores = []
        rmse_scores = []
        
        for _, row in test_df.iterrows():
            user_id = row['user_id']
            item_id = row['item_id']
            true_rating = row['rating']
            
            if component_type == 'cf':
                predicted_rating = self.cf_recommender.predict_rating(user_id, item_id)
            elif component_type == 'content':
                predicted_rating = self.content_recommender.predict_rating(user_id, item_id)
            else:  # hybrid
                predicted_rating = self.predict_rating(user_id, item_id)
            
            mae_scores.append(abs(true_rating - predicted_rating))
            rmse_scores.append((true_rating - predicted_rating) ** 2)
        
        mae = np.mean(mae_scores)
        rmse = np.sqrt(np.mean(rmse_scores))
        
        return mae, rmse
```

### 03_深度学习推荐 | Deep Learning Recommendations

**用神经网络重新定义推荐系统！**
**Redefine recommendation systems with neural networks!**

#### 神经协同过滤 | Neural Collaborative Filtering

**项目突破 | Project Breakthrough:**
神经协同过滤使用深度神经网络替代传统的矩阵分解，能够捕捉更复杂的用户-物品交互模式。

Neural Collaborative Filtering uses deep neural networks to replace traditional matrix factorization, capable of capturing more complex user-item interaction patterns.

**NCF模型实现 | NCF Model Implementation:**
```python
import torch
import torch.nn as nn
import torch.optim as optim
from torch.utils.data import Dataset, DataLoader
import torch.nn.functional as F

class NCFDataset(Dataset):
    """
    神经协同过滤数据集
    Neural Collaborative Filtering Dataset
    """
    def __init__(self, ratings_df, num_negatives=4):
        self.ratings_df = ratings_df
        self.num_negatives = num_negatives
        
        # 构建用户和物品的映射 | Build user and item mappings
        self.user_to_idx = {user: idx for idx, user in enumerate(ratings_df['user_id'].unique())}
        self.item_to_idx = {item: idx for idx, item in enumerate(ratings_df['item_id'].unique())}
        
        self.num_users = len(self.user_to_idx)
        self.num_items = len(self.item_to_idx)
        
        # 构建正样本和负样本 | Build positive and negative samples
        self.samples = self._build_samples()
    
    def _build_samples(self):
        """
        构建训练样本（正样本+负样本）
        Build training samples (positive + negative)
        """
        samples = []
        
        # 构建用户的正样本集合 | Build positive item sets for users
        user_items = self.ratings_df.groupby('user_id')['item_id'].apply(set).to_dict()
        all_items = set(self.item_to_idx.keys())
        
        for _, row in self.ratings_df.iterrows():
            user_id = row['user_id']
            item_id = row['item_id']
            rating = row['rating']
            
            user_idx = self.user_to_idx[user_id]
            item_idx = self.item_to_idx[item_id]
            
            # 正样本 | Positive sample
            samples.append((user_idx, item_idx, 1.0))
            
            # 负采样 | Negative sampling
            user_positive_items = user_items[user_id]
            negative_items = all_items - user_positive_items
            
            negative_samples = np.random.choice(
                list(negative_items), 
                size=min(self.num_negatives, len(negative_items)), 
                replace=False
            )
            
            for neg_item in negative_samples:
                neg_item_idx = self.item_to_idx[neg_item]
                samples.append((user_idx, neg_item_idx, 0.0))
        
        return samples
    
    def __len__(self):
        return len(self.samples)
    
    def __getitem__(self, idx):
        user_idx, item_idx, label = self.samples[idx]
        return torch.LongTensor([user_idx]), torch.LongTensor([item_idx]), torch.FloatTensor([label])

class NeuralCollaborativeFiltering(nn.Module):
    """
    神经协同过滤模型
    Neural Collaborative Filtering Model
    """
    def __init__(self, num_users, num_items, embedding_dim=64, hidden_dims=[128, 64]):
        super(NeuralCollaborativeFiltering, self).__init__()
        
        self.num_users = num_users
        self.num_items = num_items
        self.embedding_dim = embedding_dim
        
        # 用户和物品嵌入层 | User and item embedding layers
        self.user_embedding = nn.Embedding(num_users, embedding_dim)
        self.item_embedding = nn.Embedding(num_items, embedding_dim)
        
        # MLP层 | MLP layers
        layers = []
        input_dim = embedding_dim * 2  # 用户和物品嵌入拼接
        
        for hidden_dim in hidden_dims:
            layers.extend([
                nn.Linear(input_dim, hidden_dim),
                nn.ReLU(),
                nn.Dropout(0.2)
            ])
            input_dim = hidden_dim
        
        # 输出层 | Output layer
        layers.append(nn.Linear(input_dim, 1))
        layers.append(nn.Sigmoid())
        
        self.mlp = nn.Sequential(*layers)
        
        # 权重初始化 | Weight initialization
        self._init_weights()
    
    def _init_weights(self):
        """
        初始化权重
        Initialize weights
        """
        nn.init.normal_(self.user_embedding.weight, std=0.01)
        nn.init.normal_(self.item_embedding.weight, std=0.01)
        
        for layer in self.mlp:
            if isinstance(layer, nn.Linear):
                nn.init.xavier_normal_(layer.weight)
                nn.init.zeros_(layer.bias)
    
    def forward(self, user_idx, item_idx):
        """
        前向传播
        Forward pass
        """
        # 获取嵌入向量 | Get embedding vectors
        user_emb = self.user_embedding(user_idx.squeeze())
        item_emb = self.item_embedding(item_idx.squeeze())
        
        # 拼接用户和物品嵌入 | Concatenate user and item embeddings
        concat_emb = torch.cat([user_emb, item_emb], dim=-1)
        
        # 通过MLP得到预测分数 | Get prediction score through MLP
        output = self.mlp(concat_emb)
        
        return output.squeeze()

class NCFRecommender:
    """
    神经协同过滤推荐器
    Neural Collaborative Filtering Recommender
    """
    def __init__(self, embedding_dim=64, hidden_dims=[128, 64], learning_rate=0.001):
        self.embedding_dim = embedding_dim
        self.hidden_dims = hidden_dims
        self.learning_rate = learning_rate
        
        self.model = None
        self.user_to_idx = None
        self.item_to_idx = None
        self.idx_to_user = None
        self.idx_to_item = None
        
        self.device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
        
    def fit(self, ratings_df, epochs=50, batch_size=256):
        """
        训练神经协同过滤模型
        Train Neural Collaborative Filtering model
        """
        print("准备训练数据...")
        print("Preparing training data...")
        
        # 创建数据集 | Create dataset
        dataset = NCFDataset(ratings_df)
        dataloader = DataLoader(dataset, batch_size=batch_size, shuffle=True)
        
        # 保存映射关系 | Save mappings
        self.user_to_idx = dataset.user_to_idx
        self.item_to_idx = dataset.item_to_idx
        self.idx_to_user = {idx: user for user, idx in self.user_to_idx.items()}
        self.idx_to_item = {idx: item for item, idx in self.item_to_idx.items()}
        
        # 创建模型 | Create model
        self.model = NeuralCollaborativeFiltering(
            num_users=dataset.num_users,
            num_items=dataset.num_items,
            embedding_dim=self.embedding_dim,
            hidden_dims=self.hidden_dims
        ).to(self.device)
        
        # 优化器和损失函数 | Optimizer and loss function
        optimizer = optim.Adam(self.model.parameters(), lr=self.learning_rate)
        criterion = nn.BCELoss()
        
        print("开始训练神经协同过滤模型...")
        print("Starting Neural Collaborative Filtering training...")
        
        # 训练循环 | Training loop
        self.model.train()
        for epoch in range(epochs):
            total_loss = 0
            num_batches = 0
            
            for batch_user, batch_item, batch_label in dataloader:
                batch_user = batch_user.to(self.device)
                batch_item = batch_item.to(self.device)
                batch_label = batch_label.to(self.device)
                
                # 前向传播 | Forward pass
                predictions = self.model(batch_user, batch_item)
                loss = criterion(predictions, batch_label.squeeze())
                
                # 反向传播 | Backward pass
                optimizer.zero_grad()
                loss.backward()
                optimizer.step()
                
                total_loss += loss.item()
                num_batches += 1
            
            avg_loss = total_loss / num_batches
            if (epoch + 1) % 10 == 0:
                print(f'Epoch {epoch + 1}/{epochs}, Average Loss: {avg_loss:.4f}')
        
        print("NCF模型训练完成！")
        print("NCF model training completed!")
        
        return self
    
    def predict_rating(self, user_id, item_id):
        """
        预测用户对物品的评分
        Predict user's rating for an item
        """
        if user_id not in self.user_to_idx or item_id not in self.item_to_idx:
            return 3.0  # 默认评分
        
        self.model.eval()
        with torch.no_grad():
            user_idx = torch.LongTensor([self.user_to_idx[user_id]]).to(self.device)
            item_idx = torch.LongTensor([self.item_to_idx[item_id]]).to(self.device)
            
            prediction = self.model(user_idx, item_idx)
            
            # 转换为1-5的评分范围 | Convert to 1-5 rating scale
            rating = 1 + 4 * prediction.item()
            
        return rating
    
    def recommend_items(self, user_id, n_recommendations=10):
        """
        为用户推荐物品
        Recommend items for a user
        """
        if user_id not in self.user_to_idx:
            print(f"用户 {user_id} 不存在")
            return []
        
        self.model.eval()
        recommendations = []
        
        with torch.no_grad():
            user_idx = torch.LongTensor([self.user_to_idx[user_id]]).to(self.device)
            
            # 对所有物品进行预测 | Predict for all items
            for item_id, item_idx_val in self.item_to_idx.items():
                item_idx = torch.LongTensor([item_idx_val]).to(self.device)
                prediction = self.model(user_idx, item_idx)
                rating = 1 + 4 * prediction.item()
                recommendations.append((item_id, rating))
        
        # 按预测评分排序 | Sort by predicted rating
        recommendations.sort(key=lambda x: x[1], reverse=True)
        
        return recommendations[:n_recommendations]
```

---

**🎯 项目完成检查清单 | Project Completion Checklist:**

### 算法理解 | Algorithm Understanding
- [ ] 深入理解协同过滤的数学原理和假设
- [ ] 掌握内容推荐的特征工程和相似度计算
- [ ] 理解深度学习推荐的网络架构设计
- [ ] 能够分析不同推荐算法的优劣和适用场景

### 系统实现 | System Implementation
- [ ] 从零实现用户和物品协同过滤算法
- [ ] 构建完整的内容推荐和混合推荐系统
- [ ] 实现神经协同过滤等深度学习推荐模型
- [ ] 掌握推荐系统的评估指标和方法

### 实际应用 | Practical Applications
- [ ] 在真实数据集上获得良好的推荐效果
- [ ] 能够处理冷启动、数据稀疏等实际问题
- [ ] 构建可扩展的推荐服务架构
- [ ] 分析推荐结果的多样性和新颖性

**记住**: 推荐系统是连接用户与内容的智能桥梁。通过这个项目，你将掌握构建个性化推荐系统的完整技术栈，从经典算法到深度学习的前沿方法！

**Remember**: Recommender systems are intelligent bridges connecting users with content. Through this project, you will master the complete technology stack for building personalized recommendation systems, from classic algorithms to cutting-edge deep learning methods! 